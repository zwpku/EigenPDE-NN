import matplotlib.pyplot as plt
import MDAnalysis as mda 
from MDAnalysis import transformations
from MDAnalysis.analysis.dihedrals import Dihedral
from MDAnalysis.lib.distances import calc_dihedrals
from MDAnalysis.analysis import align, rms 

import math
import numpy as np

# This class loads MD data generated by NAMD, and then save it in txt file.
class namd_data_loader() :
    def __init__(self, Param) :

        # Initialize parameters  
        self.pdb_path = Param.pdb_path
        self.pdb_prefix = Param.pdb_prefix

        self.which_data_to_use = Param.which_data_to_use
        self.align_data_flag =  Param.align_data_flag

        self.namd_data_filename_prefix = Param.namd_data_filename_prefix
        self.namd_data_path = Param.namd_data_path
        self.temp_T = Param.temp_T

        # Compute beta depending on temperature
        self.beta = Param.namd_beta

        self.data_filename_prefix = Param.data_filename_prefix

    # Plot angle data to file
    def plot_angle_and_weight_on_grid(self, angle_data, weights):

        # Grid: [-pi, pi] x [-pi, pi] 
        numx = numy = 100
        dx = 2 * math.pi / numx
        dy = 2 * math.pi / numy

        angle_counter = np.zeros((numx, numy))
        weight_counter = np.zeros((numx, numy))

        num_data = len(angle_data)

        # Count histgram and weights 
        for i in range (num_data):

            idx = int ((angle_data[i, 0] + math.pi) / dx)
            idy = int ((angle_data[i, 1] + math.pi) / dy)

            angle_counter[idx, idy] += 1
            weight_counter[idx, idy] += weights[i]

        # Average weights for each grid cell
        for i in range (numx):
            for j in range (numy):
                if (angle_counter[i,j] > 0):
                    weight_counter[i,j] /= angle_counter[i,j]

        fig, ax = plt.subplots(1,1)
        # Show the angle counting data in 2d plot
        h = ax.imshow(angle_counter.T, extent=[-180,180, -180, 180], cmap='jet', origin='lower')
        plt.colorbar(h)

        filename = './fig/count_of_angles.eps' 
        plt.savefig(filename)

        print ('\nPlot of 2d count data saved to: %s' % filename)

        plt.clf()
        fig, ax = plt.subplots(1,1)
        # Plot may not be smooth at states where counter is zero
        h = ax.imshow(weight_counter.T, extent=[-180,180, -180, 180], cmap='jet', origin='lower')
        plt.colorbar(h)
        filename = './fig/weights_of_angles.eps' 
        plt.savefig(filename)

        print ('Plot of 2d weight data saved to: %s\n' % filename)
   
    # Compute weights for each sampled data
    def weights_of_colvars_by_pmf(self, traj_data, K) :
        
        # First, read PMF (Potential of Mean Force) on grid of angles
        colvar_pmf_filenanme = '%s/%s.pmf' % (self.namd_data_path, self.namd_data_filename_prefix)
        fp = open(colvar_pmf_filenanme)

        # The first line is not useful
        ch, num = fp.readline().split()

        # Second line
        ch, lbx, dx, numx, tmp = fp.readline().split()
        numx = int(numx)
        lbx, dx = float(lbx), float(dx) 

        # Third line
        ch, lby, dy, numy, tmp = fp.readline().split()
        numy = int(numy)
        lby, dy= float(lby), float(dy) 

        # Shift the boundary 
        lbx += dx * 0.5
        lby += dy * 0.5

        print ('2d grid mesh for angles:\n\t[%.2f, %.2f], nx=%d\n\t[%.2f, %.2f], ny=%d' % (lbx, lbx + numx * dx, numx, lby, lby + numx * dy, numy))

        # Read PMF data on mesh of angles 
        pmf_on_angle_mesh = np.loadtxt(colvar_pmf_filenanme)[:,2].reshape([numx, numy])

        # Then, compute angle values along trajectory data
        print ('[Info] Compute dihedral angles (this step might be slow)\n')

        # Two dihedral angles for data in trajectory 
        #
        # After selecting the 5 atoms which define dihedral angles, 
        # the two angles (phi, theta) are defined by atoms 0,1,2,3 and atoms 1,2,3,4. 
        phi_angles = calc_dihedrals(traj_data[:,0,:], traj_data[:,1,:], traj_data[:,2,:], traj_data[:,3,:])
        theta_angles = calc_dihedrals(traj_data[:,1,:], traj_data[:,2,:], traj_data[:,3,:], traj_data[:,4,:])

        # Compute 2d indices of angles 
        angle_idx = [[int ((phi_angles[i] * 180 / math.pi - lbx) / dx), int ((theta_angles[i] * 180 / math.pi - lby) / dy)] for i in range(K)]

        # Make sure indices are within range
        for i in range(K):
            angle_idx[i] = [min(numx-1, angle_idx[i][0]), min(numy-1, angle_idx[i][1])]

        # Obtain PMF for data according to indices on the grid 
        pmf_along_colvars = np.array([pmf_on_angle_mesh[angle_idx[i][0]][angle_idx[i][1]] for i in range(K)])

        # Compute weights using PMF
        weights_along_colvars = np.exp(-self.beta * pmf_along_colvars)

        # Rescale weights by constant 
        rescale = np.sum(weights_along_colvars) / K
        weights_along_colvars /= rescale

        print ('Length of pmf data along trajectory: %s\n\tmin-max of pmf=(%.3f, %.3f)' % (len(pmf_along_colvars), min(pmf_along_colvars), max(pmf_along_colvars)) )

        print ('\t(min,max,sum) of weights=(%.3f, %.3f, %.3f)' % (min(weights_along_colvars), max(weights_along_colvars), sum(weights_along_colvars) ) )

        # For test purpose
        print ('\tAngles of first 2 states:\n\t', phi_angles[0:2] * 180 / math.pi, theta_angles[0:2] * 180 / math.pi)

        return np.vstack((phi_angles, theta_angles)).T, weights_along_colvars

# load sampled MD data from file, and save it to txt file
    def save_namd_data_to_txt(self):

        # Names of files containing trajectory data
        pdb_filename = '%s/%s.psf' % (self.pdb_path, self.pdb_prefix)
        traj_filename = '%s/%s.dcd' % (self.namd_data_path, self.namd_data_filename_prefix)
        u = mda.Universe(pdb_filename, traj_filename)

        # Length of trajectory 
        K_total = len(u.trajectory)
        print ("[Info] Data file: %s\n\t%d states in datafile" % (traj_filename, K_total), flush=True)

        if self.align_data_flag == True : 
            # Align states by tranforming coordinates (e.g. rotation, translation...)
            ref = mda.Universe(pdb_filename, traj_filename)
            ag = u.select_atoms('all')
            transform = mda.transformations.fit_rot_trans(ag, ref) 
            u.trajectory.add_transformations(transform)
            print("[Info] Aligning data...done.", flush=True)

        selected_atoms = None
        angle_col_index = None

        #Note: the indices are hard-coded, and depend on the psf file.
        #This will be changed in future.
        if self.which_data_to_use == 'all' : 
            # Select all atoms
            selected_atoms = u.select_atoms("all")
            # Names of atoms related to dihedral angles are CY, N, CA, C, NT.
            # Indices of these 5 atoms among selected atoms
            angle_col_index = [4, 6, 8, 14, 16]
        elif self.which_data_to_use == 'nonh' : 
            # Select all atoms expect hydron (counting starts from 1)
            selected_atoms = u.select_atoms("bynum 1 5 6 7 9 11 15 16 17 19")
            # Indices of the 5 atoms (see above) among selected atoms
            angle_col_index = [1, 3, 4, 6, 8]
        else : 
            # If which_data_to_use = 'angle_atoms' or 'angle', only include atoms related to two dihedral angles
            selected_atoms = u.select_atoms("bynum 5 7 9 15 17")
            # Indices of the 5 atoms (see above) among selected atoms
            angle_col_index = [0, 1, 2, 3, 4]

        # Number of selected atoms
        atom_num = len(selected_atoms.names)

        mass_filename = './data/namd_mass.txt'
        # Mass of selected atoms
        if self.which_data_to_use == 'angle': 
            # We choose artificial mass for angles. Needs to be fixed in future.
            mass_of_selected_atoms = np.array([1.0, 1.0])
            np.savetxt(mass_filename, mass_of_selected_atoms, header='%d' % (len(mass_of_selected_atoms)), comments="", fmt="%.10f")
        else :
            mass_of_selected_atoms = selected_atoms.masses
            np.savetxt(mass_filename, np.repeat(mass_of_selected_atoms, 3), header='%d' % (3 * len(mass_of_selected_atoms)), comments="", fmt="%.10f")

        # Save the mass of selected atoms to file
        print ( '[Info] Mass of atoms saved to file:%s\n' % mass_filename )

        print ( '[Info] Loading trajectory data...\n\tNames of %d selected atoms:\n\t %s\n\tNames of angle-related atoms:\n\t %s\n' % (atom_num, selected_atoms.names, selected_atoms.names[angle_col_index]) )

        # This is a 3d vector
        traj_data = np.array([selected_atoms.positions for ts in u.trajectory])

        # Actual length of data (should be the same as K_total above)
        K = traj_data.shape[0]

        print("[Info] In total, %d states have been loaded\n[Info] Compute PMF along states\n" % K, flush=True)

        # Compute weights along trajectory according to PMF value of angles
        angle_data, weights = self.weights_of_colvars_by_pmf(traj_data[:, angle_col_index, :], K) 

        # Plot  
        self.plot_angle_and_weight_on_grid(angle_data, weights)

        # Save trajectory data to txt file
        states_file_name = './data/%s.txt' % (self.data_filename_prefix)
        if self.which_data_to_use == 'angle': 
            # Use angle data (dim=2)
            np.savetxt(states_file_name, np.concatenate((angle_data, weights.reshape((K,1))), axis=1), header='%d %d' % (K,2), comments="", fmt="%.10f")
        else : 
            # Use trajectory data of selected atoms 
            np.savetxt(states_file_name, np.concatenate((traj_data.reshape((-1, atom_num * 3)), weights.reshape((K,1))), axis=1), header='%d %d' % (K, 3 * atom_num), comments="", fmt="%.10f")

        print("Sampled data are stored to: %s" % states_file_name)
