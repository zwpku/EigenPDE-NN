import matplotlib.pyplot as plt
import MDAnalysis as mda 
from MDAnalysis import transformations
from MDAnalysis.analysis.dihedrals import Dihedral
from MDAnalysis.lib.distances import calc_dihedrals
from MDAnalysis.analysis import align, rms 

import math
import numpy as np

# This class loads MD data generated by NAMD, and then save it in txt file.
class namd_data_loader() :
    def __init__(self, Param, validation_data=False) :

        # Initialize parameters  
        self.psf_name = Param.psf_name

        self.which_data_to_use = Param.which_data_to_use
        self.use_biased_data = Param.use_biased_data
        self.align_data_flag =  Param.align_data_flag

        self.namd_data_filename_prefix = Param.namd_data_filename_prefix

        if validation_data == True :
            self.namd_data_path = Param.namd_validation_data_path
        else :
            self.namd_data_path = Param.namd_data_path

        self.temp_T = Param.temp_T

        # Compute beta depending on temperature
        self.beta = Param.namd_beta

        self.data_filename_prefix = Param.data_filename_prefix

    # Plot angle data to file
    def plot_angle_and_weight_on_grid(self):

        # Grid: [-pi, pi] x [-pi, pi] 
        numx = numy = 100
        dx = 360.0 / numx
        dy = 360.0 / numy

        angle_counter = np.zeros((numx, numy))
        weight_counter = np.zeros((numx, numy))

        num_data = len(self.angles)

        # Count histgram and weights 
        for i in range (num_data):

            idx = int ((self.angles[i, 0] + 180) / dx)
            idy = int ((self.angles[i, 1] + 180) / dy)

            angle_counter[idx, idy] += 1
            weight_counter[idx, idy] += self.weights[i]

        # Average weights for each grid cell
        for i in range (numx):
            for j in range (numy):
                if (angle_counter[i,j] > 0):
                    weight_counter[i,j] /= angle_counter[i,j]

        fig, ax = plt.subplots(1,1)
        # Show the angle counting data in 2d plot
        h = ax.imshow(angle_counter.T, extent=[-180,180, -180, 180], cmap='jet', origin='lower', vmax=10)
        plt.colorbar(h)

        filename = './fig/count_of_angles.eps' 
        plt.savefig(filename)

        print ('\nPlot of 2d count data saved to: %s' % filename)

        plt.clf()
        fig, ax = plt.subplots(1,1)
        # Plot may not be smooth at states where counter is zero
        h = ax.imshow(weight_counter.T, extent=[-180,180, -180, 180], vmax=5.0, cmap='jet', origin='lower')
        plt.colorbar(h)
        filename = './fig/weights_of_angles.eps' 
        plt.savefig(filename)

        print ('Plot of 2d weight data saved to: %s\n' % filename)

    def load_angles_from_colvar_traj(self) :

        colvar_traj_filename = '%s/%so.colvars.traj' % (self.namd_data_path, self.namd_data_filename_prefix)
        fp = open(colvar_traj_filename)

        # Read values of colvars trajectory 
        angles = np.loadtxt(colvar_traj_filename, skiprows=2)

        # Save angles of states along trajectory
        angle_output_file = './data/angle_along_traj.txt' 
        np.savetxt(angle_output_file, angles[:, 1:], header='%d' % (angles.shape[0]), comments="", fmt="%.10f")

        # For test purpose
        print ('\nAngles of first 2 states:\n\t', angles[0:2,:])
        print ('\nAngles of last 2 states:\n\t', angles[-2:,:])

        self.angles = angles[:,1:]

    # Compute weights for each sampled data
    def weights_of_colvars_by_pmf(self) :
        # First, read PMF (Potential of Mean Force) on grid of angles
        colvar_pmf_filename = '%s/%so.pmf' % (self.namd_data_path, self.namd_data_filename_prefix)
        fp = open(colvar_pmf_filename)

        # The first line is not useful
        ch, num = fp.readline().split()

        # Second line
        ch, lbx, dx, numx, tmp = fp.readline().split()
        numx = int(numx)
        lbx, dx = float(lbx), float(dx) 

        # Third line
        ch, lby, dy, numy, tmp = fp.readline().split()
        numy = int(numy)
        lby, dy= float(lby), float(dy) 

        # Shift the boundary 
        lbx += dx * 0.5
        lby += dy * 0.5

        print ('2d grid mesh for angles:\n\t[%.2f, %.2f], nx=%d\n\t[%.2f, %.2f], ny=%d' % (lbx, lbx + numx * dx, numx, lby, lby + numx * dy, numy))

        # Read PMF data on mesh of angles 
        pmf_on_angle_mesh = np.loadtxt(colvar_pmf_filename)[:,2].reshape([numx, numy])


        """
        # Then, compute angle values along trajectory data
        print ('[Info] Compute dihedral angles (this step might be slow)\n')

        # Two dihedral angles for data in trajectory 
        #
        # After selecting the 5 atoms which define dihedral angles, 
        # the two angles (phi, theta) are defined by atoms 0,1,2,3 and atoms 1,2,3,4. 
        phi_angles = calc_dihedrals(traj_data[:,0,:], traj_data[:,1,:], traj_data[:,2,:], traj_data[:,3,:])
        theta_angles = calc_dihedrals(traj_data[:,1,:], traj_data[:,2,:], traj_data[:,3,:], traj_data[:,4,:])
        """

        K_angle = self.angles.shape[0] 

        # Compute 2d indices of angles 
        angle_idx = [[int ((self.angles[i][0] - lbx) / dx), int ((self.angles[i][1] - lby) / dy)] for i in range(K_angle)]

        # Make sure indices are within range
        for i in range(K_angle):
            angle_idx[i] = [min(numx-1, angle_idx[i][0]), min(numy-1, angle_idx[i][1])]

        # Obtain PMF for data according to indices on the grid 
        pmf_along_colvars = np.array([pmf_on_angle_mesh[angle_idx[i][0]][angle_idx[i][1]] for i in range(K_angle)])

        # Compute weights using PMF
        weights_along_colvars = np.exp(-self.beta * pmf_along_colvars)

        # Rescale weights by constant 
        rescale = np.sum(weights_along_colvars) / K_angle
        weights_along_colvars /= rescale

        print ('\nLength of pmf data along trajectory: %s\n\tmin-max of pmf=(%.3f, %.3f)' % (len(pmf_along_colvars), min(pmf_along_colvars), max(pmf_along_colvars)) )

        print ('\t(min,max,sum) of weights=(%.3e, %.3e, %.3e)' % (min(weights_along_colvars), max(weights_along_colvars), sum(weights_along_colvars) ) )

        self.weights = weights_along_colvars

    def load_namd_traj(self):
        # Names of files containing trajectory data
        psf_filename = '%s/%s.psf' % (self.namd_data_path, self.psf_name)
        pdb_filename = '%s/%s.pdb' % (self.namd_data_path, self.psf_name)
        traj_filename = '%s/%s.dcd' % (self.namd_data_path, self.namd_data_filename_prefix)
        u = mda.Universe(psf_filename, traj_filename)

        # Length of trajectory 
        K_total = len(u.trajectory)
        print ("[Info] Data file: %s\n\t%d states in datafile" % (traj_filename, K_total), flush=True)

        total_time_traj = len(u.trajectory) * u.coord.dt * 1e-3 

        print ( 'Length of trajectory: %d, dt=%.2fps, total time = %.2fns\n' % (len(u.trajectory), u.coord.dt, total_time_traj) )
        print ("Time range of the trajectory: [%.4f, %.4f]\n" % (u.trajectory[0].time, u.trajectory[-1].time) )

        self.selected_atoms = None
        angle_col_index = None

        #Note: the indices are hard-coded, and depend on the psf file.
        #This will be changed in future.
        if self.which_data_to_use == 'all' : 
            # Select all atoms
            select_argument = "all"
            # Names of atoms related to dihedral angles are C, NT, CY, N, CA.
            # Indices of these 5 atoms among selected atoms
            angle_col_index = [0, 2, 12, 14, 16]
        elif self.which_data_to_use == 'nonh' : 
            # Select all atoms expect hydron (counting starts from 1)
            select_argument = "bynum 1 2 3 5 9 13 14 15 17 19"
            # Indices of the 5 atoms (see above) among selected atoms
            angle_col_index = [0, 2, 5, 7, 8]
        else : 
            # If which_data_to_use = 'angle_atoms' or 'angle', only include atoms related to two dihedral angles
            select_argument = "bynum 1 3 13 15 17"
            # Indices of the 5 atoms (see above) among selected atoms
            angle_col_index = [0, 1, 2, 3, 4]

        self.selected_atoms = u.select_atoms(select_argument)

        if self.align_data_flag != 'none' : 
            # Align states by tranforming coordinates (e.g. rotation, translation...)
            #ref = mda.Universe(psf_filename, traj_filename)
            ref = mda.Universe(pdb_filename).select_atoms("bynum 1 3 13 15 17")

            if self.align_data_flag == 'trans' : 
                transform = mda.transformations.fit_translation(u.select_atoms("bynum 1 3 13 15 17"), ref) 
            else :
                transform = mda.transformations.fit_rot_trans(u.select_atoms("bynum 1 3 13 15 17"), ref) 

            u.trajectory.add_transformations(transform)

            print("[Info] Aligning data (%s)...done." % self.align_data_flag, flush=True)

        self.load_angles_from_colvar_traj() 

        if self.use_biased_data == True : 
        
            print("[Info] Load PMF along states\n", flush=True)

            # Compute weights along trajectory according to PMF value of angles
            self.weights_of_colvars_by_pmf() 

            if self.which_data_to_use != 'angle' and self.angles.shape[0] != K_total : "colvars trajectoy (length=%d) does not match trajectory data (length=%d) " % (self.angles.shape[0], K_total)
        else :
            print("[Info] Since data are unbiased, all weights are 1\n", flush=True)
            self.weights = np.ones(K_total) 

        # Number of selected atoms
        self.atom_num = len(self.selected_atoms.names)

        print ( '\n[Info] Loading trajectory data...\n\tNames of %d selected atoms:\n\t %s\n\tNames of angle-related atoms:\n\t %s\n' % (self.atom_num, self.selected_atoms.names, self.selected_atoms.names[angle_col_index]) )

        # Change the 3d vector to 2d vector
        self.traj_data = np.array([self.selected_atoms.positions for ts in u.trajectory]).reshape((-1, self.atom_num * 3))

        print ("min, max, and mean of components: \n", np.min(self.traj_data, axis=0), np.max(self.traj_data, axis=0), np.mean(self.traj_data, axis=0) )

    def load_all(self):

        self.load_namd_traj()

        return self.traj_data, self.angles, self.weights 

# load sampled MD data from file, and save it to txt file
    def save_namd_data_to_txt(self):

        self.load_namd_traj()

        if self.use_biased_data == True : 
            # Plot PMF on angle mesh
            self.plot_angle_and_weight_on_grid()

        mass_filename = './data/namd_mass.txt'
        # Mass of selected atoms
        if self.which_data_to_use == 'angle': 
            # We choose artificial mass for angles. Needs to be fixed in future.
            mass_of_selected_atoms = np.array([1.0, 1.0])
            np.savetxt(mass_filename, mass_of_selected_atoms, header='%d' % (len(mass_of_selected_atoms)), comments="", fmt="%.10f")
        else :
            mass_of_selected_atoms = self.selected_atoms.masses
            np.savetxt(mass_filename, np.repeat(mass_of_selected_atoms, 3), header='%d' % (3 * len(mass_of_selected_atoms)), comments="", fmt="%.10f")

        # Save the mass of selected atoms to file
        print ( '[Info] Mass of atoms saved to file:%s\n' % mass_filename )

        # Save trajectory data to txt file
        states_file_name = './data/%s.txt' % (self.data_filename_prefix)

        # Actual length of data (should be the same as K_total above)
        K = self.traj_data.shape[0]

        print("[Info] In total, %d states have been loaded\n" % K, flush=True)

        # Use trajectory data of selected atoms 
        np.savetxt(states_file_name, np.concatenate((self.traj_data, self.weights.reshape((K,1))), axis=1), header='%d %d' % (K, 3 * self.atom_num), comments="", fmt="%.10f")

        print("Sampled data are stored to: %s" % states_file_name)

